// Code generated by go-enum DO NOT EDIT.
// Version: v0.9.2

// Built By: nix

package enums

import (
	"fmt"
	"strings"
)

const (
	// Base16MethodStatic is a Base16Method of type Static.
	Base16MethodStatic Base16Method = 0
	// Base16MethodDynamic is a Base16Method of type Dynamic.
	Base16MethodDynamic Base16Method = 1
)

var ErrInvalidBase16Method = fmt.Errorf("not a valid Base16Method, try [%s]", strings.Join(_Base16MethodNames, ", "))

const _Base16MethodName = "staticdynamic"

var _Base16MethodNames = []string{
	_Base16MethodName[0:6],
	_Base16MethodName[6:13],
}

// Base16MethodNames returns a list of possible string values of Base16Method.
func Base16MethodNames() []string {
	tmp := make([]string, len(_Base16MethodNames))
	copy(tmp, _Base16MethodNames)
	return tmp
}

// Base16MethodValues returns a list of the values for Base16Method
func Base16MethodValues() []Base16Method {
	return []Base16Method{
		Base16MethodStatic,
		Base16MethodDynamic,
	}
}

var _Base16MethodMap = map[Base16Method]string{
	Base16MethodStatic:  _Base16MethodName[0:6],
	Base16MethodDynamic: _Base16MethodName[6:13],
}

// String implements the Stringer interface.
func (x Base16Method) String() string {
	if str, ok := _Base16MethodMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Base16Method(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Base16Method) IsValid() bool {
	_, ok := _Base16MethodMap[x]
	return ok
}

var _Base16MethodValue = map[string]Base16Method{
	_Base16MethodName[0:6]:  Base16MethodStatic,
	_Base16MethodName[6:13]: Base16MethodDynamic,
}

// ParseBase16Method attempts to convert a string to a Base16Method.
func ParseBase16Method(name string) (Base16Method, error) {
	if x, ok := _Base16MethodValue[name]; ok {
		return x, nil
	}
	return Base16Method(0), fmt.Errorf("%s is %w", name, ErrInvalidBase16Method)
}

// MarshalText implements the text marshaller method.
func (x Base16Method) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *Base16Method) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseBase16Method(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *Base16Method) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// PreviewFormatJpg is a PreviewFormat of type Jpg.
	PreviewFormatJpg PreviewFormat = 0
	// PreviewFormatJpeg is a PreviewFormat of type Jpeg.
	PreviewFormatJpeg PreviewFormat = 1
	// PreviewFormatPng is a PreviewFormat of type Png.
	PreviewFormatPng PreviewFormat = 2
	// PreviewFormatWebm is a PreviewFormat of type Webm.
	PreviewFormatWebm PreviewFormat = 3
)

var ErrInvalidPreviewFormat = fmt.Errorf("not a valid PreviewFormat, try [%s]", strings.Join(_PreviewFormatNames, ", "))

const _PreviewFormatName = "jpgjpegpngwebm"

var _PreviewFormatNames = []string{
	_PreviewFormatName[0:3],
	_PreviewFormatName[3:7],
	_PreviewFormatName[7:10],
	_PreviewFormatName[10:14],
}

// PreviewFormatNames returns a list of possible string values of PreviewFormat.
func PreviewFormatNames() []string {
	tmp := make([]string, len(_PreviewFormatNames))
	copy(tmp, _PreviewFormatNames)
	return tmp
}

// PreviewFormatValues returns a list of the values for PreviewFormat
func PreviewFormatValues() []PreviewFormat {
	return []PreviewFormat{
		PreviewFormatJpg,
		PreviewFormatJpeg,
		PreviewFormatPng,
		PreviewFormatWebm,
	}
}

var _PreviewFormatMap = map[PreviewFormat]string{
	PreviewFormatJpg:  _PreviewFormatName[0:3],
	PreviewFormatJpeg: _PreviewFormatName[3:7],
	PreviewFormatPng:  _PreviewFormatName[7:10],
	PreviewFormatWebm: _PreviewFormatName[10:14],
}

// String implements the Stringer interface.
func (x PreviewFormat) String() string {
	if str, ok := _PreviewFormatMap[x]; ok {
		return str
	}
	return fmt.Sprintf("PreviewFormat(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x PreviewFormat) IsValid() bool {
	_, ok := _PreviewFormatMap[x]
	return ok
}

var _PreviewFormatValue = map[string]PreviewFormat{
	_PreviewFormatName[0:3]:   PreviewFormatJpg,
	_PreviewFormatName[3:7]:   PreviewFormatJpeg,
	_PreviewFormatName[7:10]:  PreviewFormatPng,
	_PreviewFormatName[10:14]: PreviewFormatWebm,
}

// ParsePreviewFormat attempts to convert a string to a PreviewFormat.
func ParsePreviewFormat(name string) (PreviewFormat, error) {
	if x, ok := _PreviewFormatValue[name]; ok {
		return x, nil
	}
	return PreviewFormat(0), fmt.Errorf("%s is %w", name, ErrInvalidPreviewFormat)
}

// MarshalText implements the text marshaller method.
func (x PreviewFormat) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *PreviewFormat) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParsePreviewFormat(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *PreviewFormat) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}
